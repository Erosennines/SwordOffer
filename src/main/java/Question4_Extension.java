/**
 * 问题4拓展：输入一个整数数组，数组中只有一个数字出现了m次，而其他数字都出现了n次。请找出那个只出现m次的数字。假设m不能被n整除。
 */
public class Question4_Extension {
    public static int singleNumber(int[] nums, int m, int n) {
        int[] bitSums = new int[32];

        for (int num : nums) {
            for (int i = 0; i < 32; i++) {
                // 将数字以32位二进制形式存入数组
                // 这样如果一个数字出现了3次，那么这个二进制数组上的bitSums[i]一定是3的倍数
                // 下面这样写是为了从左往右取二进制
                bitSums[i] += (num >> (31 - i)) & 1;
                // 以8位二进制整数01101101为例，左起第二位是1，左移5(7-2)位后得到0000 0011，再和1相与得到1，此时的1就是左起第二位1
                // 为什么要从左往右存储？答案在下面
            }
        }

        int result = 0;
        for (int i = 0; i < 32; i++) {
            result = (result << 1) + bitSums[i] % n;
        }
// (m > n)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 3, 3, 4, 7, 3, 7, 3]
// (m < n)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 3, 2, 5, 3, 5, 3]
        if (m > n) {
            return result;
        } else {
            return result / m;
        }
        // 需要说明的是，当m<n时，result的值会变大，这是由于bitSums[i] % n无法整除n，因此得到值正好就是只出现m次值的m倍
        // 3无法整除5，因此3%5=3，10无法整除19，因此10%19=10
    }


    public static void main(String[] args) {
        int[] arr = new int[]{0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 100, 100, 100, 100, 100, 10, 10, 10, 10, 10, 1050, 1050, 1050};
        System.out.println(singleNumber(arr, 3, 5));
    }
}
/*
    思路：
    一个整数是由32个0或1组成的。我们可以将数组中所有数字的同一位置的数位相加。如果将出现3次的数字单独拿出来，那么这些出现了3次的数字的任意
    第i个数位之和都能被3整除。因此，
        如果数组中所有数字的任意第i个数位之和都能被3整除，那么只出现一次的数字的第i个数位一定是0；
        如果数组中所有数字的第i个数位相加之和被3除余1，那么只出现一次的数字的第i个数位一定是1.
    这样只出现一次的任意第i个数位可以由数组中所有数字的第i个数位之和推算出来。当我们知道一个整数任意一位是0还是1之后，就可以知道它的数值。
 */